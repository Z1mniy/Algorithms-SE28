# Алгоритмы на графах

## Реализация структур хранения графа
- Список смежности
> Сложность по памяти: $O(V$ + сумма степеней всех вершин$)$ $= O(V + 2xE) = O(V + E)$

- Матрица смежности - это самый популярный и расточительный способ представления графа в памяти. Его уместно использовать, если количество рёбер велико, порядка V2.
> Сложность по памяти: $O(V^2)$

- Список ребер
>?

- Матрица инцидентности - это самый расточительный способ хранения графа, его уместно использовать, если количество рёбер невелико
> Сложность по памяти: $O(V × E)$

## Обход в глубину DFS
### Логика работы
- __рекурсивная реализация:__ выбирается начальная вершина, она помечается как посещенная. далее рекурсивно: для текущей вершины просмтариваются все соседние, если соседняя не посещена, рекурсивно вызывается DFS для неё. после обработки всех вершин, происходит backtracking.

- __итеративная реализация:__ используется стек для хранения вершин, вершина извлекается из стека, обрабатывается, а ее непосещенные соседи добавляются в стек.

- __инвариант:__ все посещенные вершины достижимы из стартовой

- __оптимизация:__ битовая маска visited, ранний выход

#### Пример рекурсивной реализации
```cpp
void dfsRecursive(int v, int from, const vector<vector<int>>& graph, vector<int>& visited) {
    if (visited[v] != 0) return;
    visited[v] = 1;
    for (int to : graph[v]) {
        if (to == from) continue;
        dfsRecursive(to, v, graph, visited);
    }
    visited[v] = 2;
}
```
#### Пример итеративной реализации
```cpp
void dfsIterative(const vector<vector<int>>& graph, int start) {
    unordered_set<int> visited;
    stack<int> stack;
    stack.push(start);
    
    while (!stack.empty()) {
        int v = stack.top();
        stack.pop();
        
        if (visited.find(v) == visited.end()) {
            visited.insert(v);
            //можно добавить кастомную обработку вершины ...
            for (auto it = graph[v].rbegin(); it != graph[v].rend(); ++it) {
                if (visited.find(*it) == visited.end()) {
                    stack.push(*it);
                }
            }
        }
    }
}
```
### Используемые структуры данных
### Асимптотика
|          |Список смежности|Матрица смежности|Список ребер|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(V^2)$|$O(V + E)$|
|По памяти|$O(V)$|$O(V)$|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- Поиск компонент связности.
- Топологическая сортировка (DAG).
- Поиск циклов, мостов, точек сочленения.
- Генерация лабиринтов, решение головоломок.




## Обход в ширину BFS 
### Логика работы
- выбирается начальная вершина, она помечается как посещенная и добавляется в очередь. извлекается вершина из очереди, обрабатываются все ее соседи, если соседняя вершина не посещена, она помечается как посещенная и добавляется в очередь. процесс продолжается,ю пока очередь не станет пустой.
- __инвариант__: все вершины в очереди находятся на расстоянии `d` или `d+1` от стартовой
- __оптимизация__:
    
    - вусторонний BFS (Bidirectional BFS) – если известна целевая вершина, запускаем BFS одновременно из старта и цели. 
    
    - Использование deque (если граф 0-1, как в алгоритме 0-1 BFS).
    
    - Сжатие координат (если вершины – точки на сетке).
    
    - Ранний выход (если нашли нужную вершину)

```cpp
void BFS(const vector<vector<int>>& graph, int start) {
	queue<int> q;
	unordered_set<int> visited;
	q.push(start);
	visited.insert(start);
	
	while (!q.empty()) {
		int v = q.front();
		q.pop();
		//...
		for (int neighbor : graph[v]) {
			if (visited.find(neighbor) == visited.end()) {
				visited.insert(neighbor);
				q.push(neighbor);
			}
		}
	}
}
```
### Используемые структуры данных
### Асимптотика
|          |Список смежности|Матрица смежности|Список ребер|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(V^2)$|$O(V + E)$|
|По памяти|$O(V)$|$O(V)$|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- поиск кратчайшего пути в невзвешенном графе
- проверка на двудольность
- поиск компонент связности
- поиск ближайших соседей





## Топологическая сортировка 
### Чи шо вообще
### Логика работы
- __DFS__ при завершении обхода вершины, добавляем ее в стек, затем его разворачиваем. (либо сразу в конец без стека)
- __алгоритм Кана__ считаем входные степени вершин, добавляем вершины с входной степенью 0 в очередь. удаляем вершины из очереди, уменьшаемм входные степени их соседей. если вершина с входной степенью 0 появилась - добавляем ее в очередь. повторяем, пока не обработаем все вершины.
- __инвариант__: вершина добавляется в порядок только после всех своих потомков (DFS); в очереди всегда находятся вершины с `in_degree = 0`, гарантируя корректный порядок (Kana).

#### Топологическая сортировка 
```cpp
void tSort(std::vector<std::vector<int>>& graph, int v, std::vector<int>& visited, std::vector<int>& order) {
    visited[v] = 1;
    for (int to : graph[v]) {
        if (visited[to] == 0) {
            tSort(graph, to, visited, order);
        }
    }
    order.push_back(v);
}
```
#### Алгоритм Кана
```cpp
vector<int> tSortKana(int v, vector<vector<int>>& edges) {
	vector<int> in_degree(V, 0);
	vector<vector<int>> adj(V);
	vector<int> result;
	
	for (const auto& edge : edges) {
		int u = edge[0], v = edge[1];
		adg[u].push_back(v);
		in_degree[v]++;
	}
	
	queue<int> q;
	for (int i = 0; i < V; ++i) {
		if (in_degree[i] == 0) {
			q.push(i);
		}
	}
	
	while (!q.empty()) {
		int node = q.front();
		q.pop();
		result.push_back(node);
		
		for (int neighbor : adj[node]) {
			in_degree[neighbor]--;
			if (in_degree[neighbor] == 0) {
				q.push(neighbor);
			}
		}
	}
	
	return result;
}
```
### Используемые структуры данных
### Асимптотика
|          |Список смежности|Матрица смежности|
|----------|--------------------|-----------------|
|По времени|$O(V + E)$|$O(V^2)$|
|По памяти|$O(V)$|$O(V)$|
### Ограничения и плюсы
### Применимость
- планирование задач с зависимостями
- разрешение зависимостей в системах управления пакетами
- обход графа зависимостей в базах данных и анализе сетей







## Конденсация графа + поиск комп слабой свзяности
### Чи шо вообще
### Логика работы
- __поиск wcc через dfs/bfs__
    
    идем по всем вершинам. если вершина не посещена, запускаем один из обходов. обходим все ребра. все посещенные вершины относятся к одной компоненте. повторяем пока не покроем все вершины.
    
- __конденсация графа__ (scc + построение dag)
    
    для поиска scc используем алгоритм Косараджу или Тарьяна
    
    >Косараджу: основан на dfs и транспониировании графа. Требует два полных обхода графа (один для сортировки, второй для обхода транспонированного). Логика работы: запускаем обход и кладём вершины в стек по завершении обхода, меняем направления всех ребер. запускаем второй dfs на транспонированном графе, достаём из стека и запускаем обход, каждое новое дерево dfs - scc
    
    >Тарьяна: основан на 1 dfs с поддержкой времени входа и низкой связи. назначаем каждой вершине entry time (бесконечное время входа), если встречаем обратное ребро обновляем low-link. если entry[v]==low[v], то вершина - корень scc, достаем все вершины из стека, пока не достигнем v.
    
    __scc__ - множество вершин, из которых можно добраться друг до друга. каждая scc становится одной вершиной. если из одной scc есть путь в другую, добавляем ребро

#### Поиск компонент слабой связности
```cpp
void dfs(int v, vector<vector<int>>& adj, vector<bool>& visited) {...}


int WCC(int V, vector<pair<int, int>>& edges) {
	vector<vector<int>> adj(V);
	vector<bool> visited(V, false);
	
	for (auto& edge : edges) {
		adj[edge.first].push_back(edge.second);
		adj[edge.second].push_back(edge.first);
	}
	
	int components = 0;
	for (int i = 0; i < V; ++i) {
		if (!visited[i]) {
				dfs(i, adj, visited);
				components++:
		}
	}
	return components;
}
```
#### Поиск компонент сильной связности Косораджу
```cpp
void dfs1(int v, vector<vector<int>>& agj, vector<bool>& visited, stack<int>& order) {...}
void dfs2(int v, vector<vector<int>>& reverse_adj, vector<bool>& visited, vector<int>& component) {...}


vector<vector<int>> findSCC(int V, vector<pair<int, int>>& edges) {
	vector<vector<int>> adj(V), reverse_adj(V);
	vector<bool> visited(V, false);
	stack<int> order;
	
	for (auto& edge : edges) {
		adj[edge.first].push_back(edge.second);
		reverse_adj[edge.second].push_back(edge.first);
	}
	
	for (int i = 0; i < V; ++i) {
		if (!visited[i]) dfs1(i, adj, visited, order);
	}
	
	fill(visited.begin(), visited.end(), false);
	vector<vector<int>> sccs;
	while (!order.empty()) {
		int v = order.top();
		order.pop();
		if (!visited[v]) {
			vector<int> component;
			dfs2(v, reverse_adj, visited, component);
			sccs.push_back(component);
		}
	}
	return sccs;
}
```
### Используемые структуры данных
### Асимптотика
|          |Поиск компонент слабой связности с использование DFS/BFS|Поиск компонент слабой связности Union-find|Конденсация графа с использованием Косарайю/Тарьяна|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(\alpha(V))$|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- анализ сетей (группировка узлов)
- разбиение зависимостей
- моделирование








## Поиск и восстановление всех видов циклов 
### Логика работы
- используем один из обходов. при обходе сохраняем текущий путь, если обнаруживается вершина, которая уже находится в текущем пути, значит мы нашли цикл. цикл восстановляется из текущего пути.
```cpp
void findCyclesDFS(int v, int parent, const vector<vector<int>>& graph, vector<bool>& visited, vector<int>& path, vector<vector<int>>& cycles) {
    visited[v] = true;
    path.push_back(v);

    for (int neighbor : graph[v]) {
        if (!visited[neighbor]) {
            findCyclesDFS(neighbor, v, graph, visited, path, cycles);
        } else if (neighbor != parent) {
            vector<int> cycle;
            int start = neighbor;
            int i = path.size() - 1;
            while (path[i] != start) {
                cycle.push_back(path[i]);
                i--;
            }
            cycle.push_back(start);
            cycles.push_back(cycle);
        }
    }

    path.pop_back();
}
```
### Используемые структуры данных
### Асимптотика
|          |Нахождение цикла|Востановление циклов ($C$ - кол-во циклов для востановления )|
|----------|--------------------|-----------------|
|По времени|$O(V + E)$|$O(C*(V + E))$|

### Ограничения и плюсы
### Применимость
- анализ в многопоточных программах





## Поиск Гамильтонова цикла при выполнении достаточных условий
### Чи шо вообще
### Логика работы

### Используемые структуры данных
### Асимптотика
|          |Стандартный случай|Худший случай|
|----------|--------------------|-----------|
|По времени|$O(n^2)$|$O(n!)$|
|По памяти|$O(V)$|$O(V)$|
### Ограничения и плюсы
### Применимость
- поиск оптимальных маршрутов
- анализ сетей





## Поиск Эйлерова цикла 
### Чи шо вообще
### Логика работы
### Используемые структуры данных
### Асимптотика
|          |Поиск Эйлерового цикла|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V + E)$|
### Ограничения и плюсы
### Применимость

## Нахождение компонент связности в неориентированном графе 
### Чи шо вообще
### Логика работы
### Используемые структуры данных
### Асимптотика
|          |Поиск комопонент связности|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V)$|
### Ограничения и плюсы
### Применимость

## Алгоритмы Краскала 
### Логика работы
### Используемые структуры данных
### Асимптотика
|          |Краскал|
|----------|--------------------|
|По времени|$O(ElogE)$|
|По памяти|$O(V + E)$|
### Ограничения и плюсы
### Применимость

## Алгоритм Прима 
### Логика работы
### Используемые структуры данных
### Асимптотика
|          |Прима через массив|Прима через приорететную очередб|
|----------|--------------------|-----------------|
|По времени|$O(V^2)$|$O(ElogV)$|
|По памяти|$O(V + E)$|$O(V + E)$|
### Ограничения и плюсы
### Применимость

## Алгоритм Беллмана-Форда (кратчайший путь, но можно отрицательный вес ребра)
### Логика работы
### Используемые структуры данных
### Асимптотика
|          |Для списка смежности|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V)$|

*в случае с полным графом по времени $O(V^3)$
### Ограничения и плюсы
### Применимость
