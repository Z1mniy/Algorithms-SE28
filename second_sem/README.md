# Алгоритмы на графах

## Реализация структур хранения графа
- Список смежности
> Сложность по памяти: $O(V$ + сумма степеней всех вершин$)$ $= O(V + 2xE) = O(V + E)$

- Матрица смежности - это самый популярный и расточительный способ представления графа в памяти. Его уместно использовать, если количество рёбер велико, порядка V2.
> Сложность по памяти: $O(V^2)$

- Список ребер
> Сложность по памяти: $O(E)$

- Матрица инцидентности - это самый расточительный способ хранения графа, его уместно использовать, если количество рёбер невелико
> Сложность по памяти: $O(V × E)$

## Обход в глубину DFS
### Логика работы
- __рекурсивная реализация:__ выбирается начальная вершина, она помечается как посещенная. далее рекурсивно: для текущей вершины просмтариваются все соседние, если соседняя не посещена, рекурсивно вызывается DFS для неё. после обработки всех вершин, происходит backtracking.

- __итеративная реализация:__ используется стек для хранения вершин, вершина извлекается из стека, обрабатывается, а ее непосещенные соседи добавляются в стек.

- __инвариант:__ все посещенные вершины достижимы из стартовой

- __оптимизация:__ битовая маска visited, ранний выход

#### Псевдокод
```
function doDfs(G[n]: Graph): // функция принимает граф G с количеством вершин n и выполняет обход в глубину во всем графе 
   visited = array[n, false]  // создаём массив посещённых вершины длины n, заполненный false изначально
          
   function dfs(u: int):   
      visited[u] = true
      for v: (u, v) in G        
         if not visited[v]               
            dfs(v)

   for i = 1 to n             
      if not visited[i]                    
         dfs(i)
```
#### Пример рекурсивной реализации
```cpp
void dfsRecursive(int v, int from, const vector<vector<int>>& graph, vector<int>& visited) {
    if (visited[v] != 0) return;
    visited[v] = 1;
    for (int to : graph[v]) {
        if (to == from) continue;
        dfsRecursive(to, v, graph, visited);
    }
    visited[v] = 2;
}
```
#### Пример итеративной реализации
```cpp
void dfsIterative(const vector<vector<int>>& graph, int start) {
    unordered_set<int> visited;
    stack<int> stack;
    stack.push(start);
    
    while (!stack.empty()) {
        int v = stack.top();
        stack.pop();
        
        if (visited.find(v) == visited.end()) {
            visited.insert(v);
            //можно добавить кастомную обработку вершины ...
            for (auto it = graph[v].rbegin(); it != graph[v].rend(); ++it) {
                if (visited.find(*it) == visited.end()) {
                    stack.push(*it);
                }
            }
        }
    }
}
```
### Используемые структуры данных
- рекурсивная реализация использует стек вызовов
- итеративная реализация - явный стек
- массив/множество visited
### Асимптотика
|          |Список смежности|Матрица смежности|Список ребер|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(V^2)$|$O(V + E)$|
|По памяти|$O(V)$|$O(V)$|$O(V + E)$|
### Ограничения и плюсы

### Применимость
- Поиск компонент связности.
- Топологическая сортировка (DAG).
- Поиск циклов, мостов, точек сочленения.
- Генерация лабиринтов, решение головоломок.




## Обход в ширину BFS 
### Логика работы
- выбирается начальная вершина, она помечается как посещенная и добавляется в очередь. извлекается вершина из очереди, обрабатываются все ее соседи, если соседняя вершина не посещена, она помечается как посещенная и добавляется в очередь. процесс продолжается,ю пока очередь не станет пустой.
- __инвариант__: все вершины в очереди находятся на расстоянии `d` или `d+1` от стартовой
- __оптимизация__:
    
    - вусторонний BFS (Bidirectional BFS) – если известна целевая вершина, запускаем BFS одновременно из старта и цели. 
    
    - Использование deque (если граф 0-1, как в алгоритме 0-1 BFS).
    
    - Сжатие координат (если вершины – точки на сетке).
    
    - Ранний выход (если нашли нужную вершину)
#### Псевдокод
- $source$ — исходная вершина
- $destination$ — конечная вершина
- $G$ — граф, состоящий из списка вершин V и списка смежности E. Вершины нумеруются целыми числами.
- $Q$ — очередь.
- В поле `d[u]` хранится расстояние от source до u.
```
int BFS(G: (V, E), source: int, destination: int):
    d = int[|V|]
    fill(d, ∞)
    d[source] = 0
    Q = ∅

    Q.push(source)
    while Q ≠∅
 
        u = Q.pop()
        for v: (u, v) in E
            if d[v] == ∞

                d[v] = d[u] + 1
                Q.push(v)
    return d[destination]
```
#### Пример кода
```cpp
void BFS(const vector<vector<int>>& graph, int start) {
	queue<int> q;
	unordered_set<int> visited;
	q.push(start);
	visited.insert(start);
	
	while (!q.empty()) {
		int v = q.front();
		q.pop();
		//...
		for (int neighbor : graph[v]) {
			if (visited.find(neighbor) == visited.end()) {
				visited.insert(neighbor);
				q.push(neighbor);
			}
		}
	}
}
```

### Используемые структуры данных
- массив посещенных вершин
- очередь. всегда ее используем

### Асимптотика
|          |Список смежности|Матрица смежности|Список ребер|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(V^2)$|$O(V + E)$|
|По памяти|$O(V)$|$O(V)$|$O(V + E)$|

### Ограничения и плюсы

### Применимость
- поиск кратчайшего пути в невзвешенном графе
- проверка на двудольность
- поиск компонент связности
- поиск ближайших соседей





## Топологическая сортировка 
### Чи шо вообще
Это упорядочивание вершин таким образом, что для любого ребра (u, v) вершина u всегда стоит перед вершиной v.

Задача топологической сортировки графа звучит так: дан ориентированный граф, и требуется найти такой порядок вершин, в котором все рёбра графа вели из более ранней вершины в более позднюю.

### Логика работы
- __DFS__ при завершении обхода вершины, добавляем ее в стек, затем его разворачиваем. (либо сразу в конец без стека)
- __алгоритм Кана__ считаем входные степени вершин, добавляем вершины с входной степенью 0 в очередь. удаляем вершины из очереди, уменьшаемм входные степени их соседей. если вершина с входной степенью 0 появилась - добавляем ее в очередь. повторяем, пока не обработаем все вершины.
- __инвариант__: вершина добавляется в порядок только после всех своих потомков (DFS); в очереди всегда находятся вершины с `in_degree = 0`, гарантируя корректный порядок (Kana).


#### Псевдокод
```
// G — исходный граф
function topologicalSort(): проверить граф G на ацикличность
    fill(visited,false)
    for v∈V(G)
        if not visited[v]
             dfs(v)
    ans.reverse()

function dfs(u):
    visited[u]=true
    for uv ∈ E(G)
        if not visited[v]
            dfs(v)
    ans.pushBack(u)
```

#### Топологическая сортировка 
```cpp
void tSort(std::vector<std::vector<int>>& graph, int v, std::vector<int>& visited, std::vector<int>& order) {
    visited[v] = 1;
    for (int to : graph[v]) {
        if (visited[to] == 0) {
            tSort(graph, to, visited, order);
        }
    }
    order.push_back(v);
}
```

#### Алгоритм Кана
```cpp
vector<int> tSortKana(int v, vector<vector<int>>& edges) {
	vector<int> in_degree(V, 0);
	vector<vector<int>> adj(V);
	vector<int> result;
	
	for (const auto& edge : edges) {
		int u = edge[0], v = edge[1];
		adg[u].push_back(v);
		in_degree[v]++;
	}
	
	queue<int> q;
	for (int i = 0; i < V; ++i) {
		if (in_degree[i] == 0) {
			q.push(i);
		}
	}
	
	while (!q.empty()) {
		int node = q.front();
		q.pop();
		result.push_back(node);
		
		for (int neighbor : adj[node]) {
			in_degree[neighbor]--;
			if (in_degree[neighbor] == 0) {
				q.push(neighbor);
			}
		}
	}
	
	return result;
}
```

### Используемые структуры данных
- массив посещенных
- стек (DFS)
- очередь (алгоритм Кана)

### Асимптотика
|          |Список смежности|Матрица смежности|
|----------|--------------------|-----------------|
|По времени|$O(V + E)$|$O(V^2)$|
|По памяти|$O(V)$|$O(V)$|

### Ограничения и плюсы

### Применимость
- планирование задач с зависимостями
- разрешение зависимостей в системах управления пакетами
- обход графа зависимостей в базах данных и анализе сетей







## Конденсация графа + поиск комп слабой свзяности

### Чи шо вообще
__Конденсацией__ орграфа $G$ называют такой орграф $G'$, вершинами которого служат компоненты сильной связности $G$, а дуга в $G'$ присутствует только если существует хотя бы одно ребро между вершинами, входящими в соответствующие компоненты связности. Конденсация графа не содержит кратных ребер.

__Слабая связность__ - вершины связаны в неориентированой версии графа.

__Сильная связность__ - пары вершин - путь.

### Логика работы
- __поиск wcc через dfs/bfs__
    
    идем по всем вершинам. если вершина не посещена, запускаем один из обходов. обходим все ребра. все посещенные вершины относятся к одной компоненте. повторяем пока не покроем все вершины.
    
- __конденсация графа__ (scc + построение dag)
    
    для поиска scc используем алгоритм Косараджу или Тарьяна
    
    >Косараджу: основан на dfs и транспониировании графа. Требует два полных обхода графа (один для сортировки, второй для обхода транспонированного). Логика работы: запускаем обход и кладём вершины в стек по завершении обхода, меняем направления всех ребер. запускаем второй dfs на транспонированном графе, достаём из стека и запускаем обход, каждое новое дерево dfs - scc
    
    >Тарьяна: основан на 1 dfs с поддержкой времени входа и низкой связи. назначаем каждой вершине entry time (бесконечное время входа), если встречаем обратное ребро обновляем low-link. если entry[v]==low[v], то вершина - корень scc, достаем все вершины из стека, пока не достигнем v.
    
    __scc__ - множество вершин, из которых можно добраться друг до друга. каждая scc становится одной вершиной. если из одной scc есть путь в другую, добавляем ребро

#### Псевдокод
```
function dfs1(v):                                          
	color[v] = 1
	for (v, u) in E
		if not visited[u]
			dfs1(G[v][u])
	Добавляем вершину v в конец списка ord

function dfs2(v):                                          
	component[v] = col
	for (v, u) in E
		if (вершина u еще не находится ни в какой компоненте)                       
			dfs2(H[v][u])

function main():
	считываем исходные данные, формируем массивы G и H
	for u in V                           
		if not visited[u]
			dfs1(u)
	col = 1
	for (по всем вершинам u списка ord[] в обратном порядке)                                                        
		if (вершина u не находится ни в какой компоненте)
			dfs2(u)
			col++
```
#### Поиск компонент слабой связности
```cpp
void dfs(int v, vector<vector<int>>& adj, vector<bool>& visited) {...}


int WCC(int V, vector<pair<int, int>>& edges) {
	vector<vector<int>> adj(V);
	vector<bool> visited(V, false);
	
	for (auto& edge : edges) {
		adj[edge.first].push_back(edge.second);
		adj[edge.second].push_back(edge.first);
	}
	
	int components = 0;
	for (int i = 0; i < V; ++i) {
		if (!visited[i]) {
				dfs(i, adj, visited);
				components++:
		}
	}
	return components;
}
```
#### Поиск компонент сильной связности Косораджу
```cpp
void dfs1(int v, vector<vector<int>>& agj, vector<bool>& visited, stack<int>& order) {...}
void dfs2(int v, vector<vector<int>>& reverse_adj, vector<bool>& visited, vector<int>& component) {...}


vector<vector<int>> findSCC(int V, vector<pair<int, int>>& edges) {
	vector<vector<int>> adj(V), reverse_adj(V);
	vector<bool> visited(V, false);
	stack<int> order;
	
	for (auto& edge : edges) {
		adj[edge.first].push_back(edge.second);
		reverse_adj[edge.second].push_back(edge.first);
	}
	
	for (int i = 0; i < V; ++i) {
		if (!visited[i]) dfs1(i, adj, visited, order);
	}
	
	fill(visited.begin(), visited.end(), false);
	vector<vector<int>> sccs;
	while (!order.empty()) {
		int v = order.top();
		order.pop();
		if (!visited[v]) {
			vector<int> component;
			dfs2(v, reverse_adj, visited, component);
			sccs.push_back(component);
		}
	}
	return sccs;
}
```
### Используемые структуры данных
- орграф и неориентированный граф
- список смежности
- матрица смежности
- очередь или стек для обхода
- __DSU(Union-Find)__ - для эффективного объединения компонент.
    
    это структура данныз, которая поддерживает динамическое объединение множеств и поиск представителя множества.
    
    без оптимизации работает за $O(n)$, с оптимизацией за $O( \alpha n)$ используется сжатие пути + ранг(глубина)
    
    подходит только для динамических непересекающихся множеств. не дает прямой информации о количестве элементов в каждом множестве. очень быстрая работа почти за $O(1)$


### Асимптотика
|          |Поиск компонент слабой связности с использование DFS/BFS|Поиск компонент слабой связности Union-find|Конденсация графа с использованием Косарайю/Тарьяна|
|----------|--------------------|-----------------|------------|
|По времени|$O(V + E)$|$O(\alpha(V))$|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- анализ сетей (группировка узлов)
- разбиение зависимостей
- моделирование








## Поиск и восстановление всех видов циклов 

### Логика работы
- используем один из обходов. при обходе сохраняем текущий путь, если обнаруживается вершина, которая уже находится в текущем пути, значит мы нашли цикл. цикл восстановляется из текущего пути.

```cpp
void findCyclesDFS(int v, int parent, const vector<vector<int>>& graph, vector<bool>& visited, vector<int>& path, vector<vector<int>>& cycles) {
    visited[v] = true;
    path.push_back(v);

    for (int neighbor : graph[v]) {
        if (!visited[neighbor]) {
            findCyclesDFS(neighbor, v, graph, visited, path, cycles);
        } else if (neighbor != parent) {
            vector<int> cycle;
            int start = neighbor;
            int i = path.size() - 1;
            while (path[i] != start) {
                cycle.push_back(path[i]);
                i--;
            }
            cycle.push_back(start);
            cycles.push_back(cycle);
        }
    }

    path.pop_back();
}
```
### Используемые структуры данных
- стек, список смежности, матрица смежности, очередь
### Асимптотика
|          |Нахождение цикла|Востановление циклов ($C$ - кол-во циклов для востановления )|
|----------|--------------------|-----------------|
|По времени|$O(V + E)$|$O(C*(V + E))$|

### Ограничения и плюсы
### Применимость
- анализ в многопоточных программах





## Поиск Гамильтонова цикла при выполнении достаточных условий
### Чи шо вообще
Замкнутый простой путь, проходящий через каждую вершину графа ровно один раз.
### Логика работы
- выбирается начальная вершина, рекурсивно: для текущей вершины проверяются все непосещенные соседи, если она не посещена, она добавляется в текущий путь. если путь содержит все вершины и есть ребро обратно в начальную вершину, найден гамильтов цикл

#### Псевдокод
```
function findHamiltonianCycle(⟨V,E⟩):
	for v∈V:                                          // Добавляем все вершины графа в очередь
	queue.pushBack(v)
	for k = 0..n * (n - 1)
	if (queue.at(0), queue.at(1)) ∉ E // Проверяем существования ребра между первой и второй вершинами очереди
		i = 2                                             
		while (queue.at(0), queue.at(i)) ∉ E or (queue.at(1), queue.at(i + 1)) ∉E
			i++                                         // Ищем индекс удовлетворяющую условию вершины
		queue.swapSubQueue(1, i)                        // Разворачиваем часть перестановки от 1-й до найденной позиции включительно
	queue.pushBack(queue.top())
	queue.pop()
```
#### Пример кода
```cpp
bool isSafe(int v, const vector<vector<int>>& graph, const vector<int>& path, int pos) {
    if (graph[path[pos - 1]][v] == 0) {
        return false;
    }
    for (int i = 0; i < pos; ++i) {
        if (path[i] == v) {
            return false;
        }
    }

    return true;
}

bool hamiltonianCycleUtil(const vector<vector<int>>& graph, vector<int>& path, int pos) {
    int n = graph.size();
    if (pos == n) {
        if (graph[path[pos - 1]][path[0]] == 1) {
            return true;
        } else {
            return false;
        }
    }

    for (int v = 1; v < n; ++v) {
        if (isSafe(v, graph, path, pos)) {
            path[pos] = v;
            if (hamiltonianCycleUtil(graph, path, pos + 1)) {
                return true;
            }
            path[pos] = -1;
        }
    }

    return false;
}
```

### Используемые структуры данных
- список смежности, матрица смежности

### Асимптотика
|          |Стандартный случай|Худший случай|
|----------|--------------------|-----------|
|По времени|$O(n^2)$|$O(n!)$|
|По памяти|$O(V)$|$O(V)$|

### Ограничения и плюсы

### Применимость
- поиск оптимальных маршрутов
- анализ сетей





## Поиск Эйлерова цикла 

### Чи шо вообще
Замкнутый путь, который проходит по каждому ребру, причем ровно один раз.

### Логика работы
- используем DFS, ребра удаляются после их посещения, вершины добавляются в цикл в порядке их завершения

```cpp
void eulerianCycleUtil(int v, vector<vector<int>>& graph, vector<int>& cycle) {
    while (!graph[v].empty()) {
        int u = graph[v].back();
        graph[v].pop_back();
        eulerianCycleUtil(u, graph, cycle);
    }
    cycle.push_back(v);
}

vector<int> findEulerianCycle(vector<vector<int>>& graph, int numVertices) {
    vector<int> cycle;
    for (int i = 0; i < numVertices; ++i) {
        if (graph[i].size() % 2 != 0) {
            cout << "Эйлеров цикл не существует" << endl;
            return {};
        }
    }
    eulerianCycleUtil(0, graph, cycle);
    for (int i = 0; i < numVertices; ++i) {
        if (!graph[i].empty()) {
            cout << "Эйлеров цикл не существует" << endl;
            return {};
        }
    }
    reverse(cycle.begin(), cycle.end());
    return cycle;
}
```

### Используемые структуры данных
- список смежности, матрица смежности

### Асимптотика
|          |Поиск Эйлерового цикла|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V + E)$|

### Ограничения и плюсы

### Применимость
- поиск оптимальных маршрутов
- анализ сетей







## Нахождение компонент связности в неориентированном графе 

### Чи шо вообще
Набор вершин графа, между любой парой которых существует путь
### Логика работы
- создаем массив доля хранения посещенных вершин, при обходе для каждой непосещенной вершины запускаем обход, ве вершины, достижимые из текущей будут включены в одному компоненту связности. повторяем процесс, пока все вершины не будут посещены.
```cpp
void dfs(int v, const vector<vector<int>>& graph, vector<bool>& visited, vector<int>& component) {
    visited[v] = true;
    component.push_back(v);

    for (int neighbor : graph[v]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited, component);
        }
    }
}

vector<vector<int>> findConnectedComponents(const vector<vector<int>>& graph, int numVertices) {
    vector<bool> visited(numVertices, false);
    vector<vector<int>> components;

    for (int i = 0; i < numVertices; ++i) {
        if (!visited[i]) {
            vector<int> component;
            dfs(i, graph, visited, component);
            components.push_back(component);
        }
    }

    return components;
}
```
### Используемые структуры данных
- список смежности, матрица смежности
### Асимптотика
|          |Поиск комопонент связности|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V)$|
### Ограничения и плюсы
### Применимость
- анализ графов (электрические цепи, транспортные сети)







## Алгоритмы Краскала 
### Логика работы
- сортируем ребра по возрастанию. Каждая вершина графа будет представлять собой отдельное множество. далее обход ребер: для каждого ребра проверяется, принадлежат ли его вершины разным множества, если да, то ребро добавляется в остовое дерева, а множества объединяются, если нет, то ребро пропускается (иначе мы получим цикл). процесс продолжает пока не обработаны все ребра или пока не будет найдено V - 1 ребро.
- __инвариант__: на каждом шаге алгоритма множество выбранных ребер образует лес(набор деревьев) и каждое новое ребро добавляется так, чтобы не образовывать циклов
- __оптимизация__: сортировка ребер, ранняя остановка (V - 1 ребро), параллельная обработка (несколько потоков обработки)

```cpp
struct Edge {
    int src, dest, weight;
};

class DSU {
    vector<int> parent, rank;

public:
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    int find(int u) {
        if (parent[u] != u) {
            parent[u] = find(parent[u]);
        }
        return parent[u];
    }

    void unite(int u, int v) {
        int rootU = find(u);
        int rootV = find(v);

        if (rootU != rootV) {
            if (rank[rootU] > rank[rootV]) {
                parent[rootV] = rootU;
            } else if (rank[rootU] < rank[rootV]) {
                parent[rootU] = rootV;
            } else {
                parent[rootV] = rootU;
                rank[rootU]++;
            }
        }
    }
};

bool compareEdges(const Edge& a, const Edge& b) {
    return a.weight < b.weight;
}

vector<Edge> kruskalMST(vector<Edge>& edges, int numVertices) {
    sort(edges.begin(), edges.end(), compareEdges);

    DSU dsu(numVertices);
    vector<Edge> mst;

    for (const Edge& edge : edges) {
        int u = edge.src;
        int v = edge.dest;
        if (dsu.find(u) != dsu.find(v)) {
            mst.push_back(edge);
            dsu.unite(u, v);
        }
    }

    return mst;
}
```
### Используемые структуры данных
- список ребер
- система непересекающихся множеств
### Асимптотика
|          |Краскал|
|----------|--------------------|
|По времени|$O(ElogE)$|
|По памяти|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- поиск MST
- решение задач с минимизацией суммарного веса ребер







## Алгоритм Прима 
### Логика работы
1. Инициализация:
    - Выбираем произвольную стартовую вершину
    - Инициализируем массив ключей (∞) и родителей (-1)
2. Основной цикл:
    - Находим вершину с минимальным ключом
    - Добавляем её в MST
    - Обновляем ключи соседних вершин
    - Повторяем, пока все вершины не будут включены в MST
3. Завершение:
    - Формируем MST из массива родителей
- __инвариант__
    
    На каждом шаге алгоритма:
    
    1. Множество вершин в MST образует связное поддерево
    2. Для всех вершин вне MST хранится минимальный вес ребра, соединяющего их с MST
    3. Следующая добавляемая вершина гарантированно даёт минимальное расширение MST
- __оптимизация__: использование min-heap $O(logV)$ на операцию, кучи Фибоначчи $O(E + VlogV)$, ранняя остановка $(V-1)$

#### Псевдокод
```
// G — исходный граф
// w — весовая функция
function primFindMST():
	for v ∈ V(G)
       key[v] = ∞
       p[v] = null
   	r = произвольная вершина графа G
   	key[r] = 0

   	Q.push(V(G))
 
   	while not Q.isEmpty()
       v = Q.extractMin()
       for vu ∈ E(G)
           if u ∈ Q and key[u]>w(v,u)
               p[u] = v
               key[u] = w(v,u)
               Q.decreaseKey(u,key[u])
```

#### Пример кода
```cpp
typedef pair<int, int> pii;

vector<vector<pii>> adj;

void primMST(int V) {
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    vector<int> key(V, INT_MAX);
    vector<int> parent(V, -1);
    vector<bool> inMST(V, false);

    pq.push({0, 0});
    key[0] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        
        inMST[u] = true;

        for (auto &[weight, v] : adj[u]) {
            if (!inMST[v] && weight < key[v]) {
                key[v] = weight;
                parent[v] = u;
                pq.push({key[v], v});
            }
        }
    }
    cout << "Рёбра MST:\n";
    for (int i = 1; i < V; ++i)
        cout << parent[i] << " - " << i << " : " << key[i] << endl;
}
```
### Используемые структуры данных
- матрица смежности (для плотных графов)
- список смежности (для разреженных графов)
- массивы для хранения ключей и родителей
### Асимптотика
|          |Прима через массив|Прима через приорететную очередб|
|----------|--------------------|-----------------|
|По времени|$O(V^2)$|$O(ElogV)$|
|По памяти|$O(V + E)$|$O(V + E)$|
### Ограничения и плюсы
### Применимость
- телекоммуникации, проектирование маршрутов, компьютерная графика







## Алгоритм Беллмана-Форда (кратчайший путь, но можно отрицательный вес ребра)
### Логика работы
1. Инициализация:
    - Установка расстояния до стартовой вершины = 0
    - Все остальные расстояния = ∞
2. Релаксация рёбер:
    - V-1 раз повторяем:
        
        Для каждого ребра (u, v) с весом w:
        
        Если d[u] + w < d[v], то обновляем d[v] = d[u] + w
        
3. Проверка на отрицательные циклы:
    - Если на V-ой итерации происходит обновление — есть отрицательный цикл
- *инвариант*
    - после i-й итерации внешнего цикла алгоритм находит все кратчайшие пути длиной ≤ i ребер
    - гарантирует нахождение кратчайших путей при отсутствии отрицательных циклов за V-1 итерацию
- *оптимизация*: ранняя остановка (если не происходит обновления `dist`), очередь, параллельная обработка
#### Псевдокод
```
bool fordBellman(s):
    for v ∈ V
		d[v] = 1
    d[s] = 0
    for i = 0 to |V|−1
        for (u,v) ∈ E
            if d[v] > d[u] + ω(u,v) // ω(u,v) — вес ребра uv
                d[v] = d[u] + ω(u,v)
    for (u,v) ∈ E
        if d[v] > d[u] + ω(u,v)
            return false
    return true
```
#### Пример кода
```cpp
struct Edge {
    int src, dest, weight;
};

void BellmanFord(vector<Edge>& edges, int V, int E, int src) {
    vector<int> dist(V, INT_MAX);
    dist[src] = 0;

    // Релаксация всех рёбер V-1 раз
    for (int i = 1; i <= V-1; i++) {
        for (const auto& edge : edges) {
            int u = edge.src;
            int v = edge.dest;
            int w = edge.weight;
            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }

    // Проверка на отрицательные циклы
    for (const auto& edge : edges) {
        int u = edge.src;
        int v = edge.dest;
        int w = edge.weight;
        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
            cout << "Граф содержит отрицательный цикл!" << endl;
            return;
        }
    }

    // Вывод результатов
    cout << "Вершина\tРасстояние от источника\n";
    for (int i = 0; i < V; ++i)
        cout << i << "\t\t" << dist[i] << endl;
}
```
### Используемые структуры данных
- список ребер
- список смежности
- матрица смежности

### Асимптотика
|          |Для списка смежности|
|----------|--------------------|
|По времени|$O(V + E)$|
|По памяти|$O(V)$|

*в случае с полным графом по времени $O(V^3)$

### Ограничения и плюсы
### Применимость
- маршрутизация в сетях
- обработка графиков зависимостей
