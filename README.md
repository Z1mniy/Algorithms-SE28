# Асимптотика
---
## По времени
---
**Асимптотический анализ** — метод описания предельного поведения функций.

#### имеется три обозначения:
##### **O(f(n))** - верхнее ограничение сложности алгоритма.
- **O — _f(n) = O(g(n))_**. Есть положительное число `c`, которое, начиная с `n`, всегда выполняет условие 0 <= f(n) <= c × g(n).
- _**Границы**_ скорости роста времени выполнения алгоритма. Пусть `f(n)` — время выполнения алгоритма, а `g(n)` — заданная временная сложность, которая проверяется для алгоритма. Тогда `f(n)` — это O(g(n)), если существуют действительные константы c (c > 0) и n0, такие, что `f(n)` <= `c g(n)` выполняется для всех n, начиная с некоторого n0 (n > n0)

___Пример 1___
```
f(n) = 3log n + 100
g(n) = log n
```
Является ли `f(n)` O(g(n))?
Является ли `3 log n + 100` O(log n)? 

Посмотрим на определение О Большого:
```
3log n + 100 <= c * log n
```

Существуют ли константы c и n0, такие, что выражение верно для всех n > n0?
```
3log n + 100 <= 150 * log n, n > 2 (не определенно для n = 1)
```
Да! По определению О Большого `f(n)` является O(g(n)).

___Пример 2___
```
f(n) = 3 * n^2
g(n) = n
```
Является ли `f(n)` O(g(n))? Является ли `3 * n^2` O(n)? 

Посмотрим на определение О Большого:
```
3 * n^2 <= c * n
```
Существуют ли константы c и n0, такие, что выражение верно для всех n > n0?
Нет, не существуют. `f(n)` НЕ ЯВЛЯЕТСЯ O(g(n))

##### **Ω(f(n))** (омега)- наилучшая или нижняя граница временной сложности.
- __Омега — _f(n) = Ω(g(n))___. Есть положительное число `c` , которое, начиная с `n`, всегда выполняет условие 0 <= c × g(n) <= f(n).
##### **Ө(f(n))** (тета) - точное определение (существует, когда O(g(n)) = Ω(f(n)) => = Ө(f(n))). f(n) является Θ(g(n)) означает, что f(n) является O(g(n)) и f(n) является Ω(g(n)).
- __Тета — _f(n) = ϴ(g(n))___. Есть два положительных числа `c1` и `c2`, которые, начиная с `n`, всегда выполняют условие c1 × g(n) <= f(n) <= c2 × g(n).
#### **o малое (o(n))** — позволяет оценить верхнюю границу, исключая точную оценку. 
_p.s ни разу нигде не видела, но на всякий случай_

##### Основные правила: 
1. O(n) + O(n) = O(2n) = O(n)
   O(n) + O(n^2) = O(n^2).  ___Короче самый быстрорастущий побеждает___
2. O(n) * O(n) = O(n ^ 2)
   O(n) * O(n ^ 2) * O(1) = O(n ^ 3)
3. Просто пример: O(2 ^ n) + O(n ^ 2). Здесь надо смотреть, что возрастает быстрее. Степень двойки быстрее, значит это будет равно просто O(2 ^ n)

p.s Алгоритмы, которые можно описать с помощью нотации `O(n^2 + n + 3)` или `O(n^2-100000)`, или даже `O(n^2 + 100000000)` все равно считаются квадратными. При большом количестве входных данных только наибольшая степень ___n___ является важной. Константы и коэффициенты обычно не берут во внимание. То же самое касается линейных и логарифмических функций. `O( n + 1000 )` и `O(1000×n)` все равно будут работать в `0(n)`.
#### Давайте рассмотрим примеры:
- В функции f (n) = n^2 + 3n при n -> бесконечности, 3n становится ничтожно малой по сравнению с n^2, поэтому записывают так: f(n) ~ n^2 и O(f(n)) =  n^2. Этот принцип очень часто встречается при оценке алгоритма.
```cpp
int main() {
   int n, k = 0; cin >> n; // 1 + 1 + 1 операций
   for (int i = 0; i < n; i++) { //произведет n опер.
       k++;
   }

   for (int i = 0; i < n; i++) { // n опер.
       for (int j = 0; j < n; j++) { n опер.
           k++; => выполнится n * n раз 
       }
   }
   cout << k;
}
```
_Сложность по времени будет f(n) = 3 (константы всегда отбрасываются) + n + n^2. Пользуясь правилом, говорим, O(n^2)_

- Асимптотика O(1) - значит константная, когда не зависит от никаких переменных. В целом, это очень хорошо. O(n) - линейная, O(n^2) - квадратная. Давайте рассмотрим следующий код
```cpp
int main() {
   int n, k; cin >> n >> k;
   for (int i = 1; i < n; i++) {
       i *= k;
   }
}
```
_**За сколько он отработает?**_ Меня это спросили на защите. 
Всегда очень удобно подставить рандомные числа и посмотреть сколько совершится операций. Для n = 10, k = 3 результатом будет 3. Очень напоминает логарифм, а так и есть. __Ответ: O(log от n по k)__

Когда мы делаем разбиение массивов (при сортировке), бинарный поиск, то мы всегда в таких случаях делим массив на два, соответственно таких разбиений будет log2(n). а если мы еще после каждого разбиение обрабатываем массив, то делаем при каждом разбиении n  операций => log2n * n => **получаем O(nlogn)!!!**

**Вывод такой:** Чтобы оценить алгоритм, мы всегда рассматриваем самый худший случай (потому что мы ищем O(f(n))).



### Полезные заметки

**Зачем нужно уметь определять асимптотику?** 

Когда думаешь над решением к задаче, нужно сразу понимать за сколько примерно оно будет работать. Например, задачу можно решить перебором (О(n^2)), но во входных данных `0 < n < 10^5` и время работы `< 1 сек!` Но ведь в С++ в секунду выполняется ~10^7 операций. Получается, при O(n^2) будет 10 ^ 14 операций (100 секунд) и код не зайдет. Поняв это, вы не будете тратить время на его написание, а сразу пойдете думать над другим решением.
Посмотрев на ограничения, можно предположить, что решение будет работать за O(nlogn), потому что для O(n) слишком щадящие ограничения, для O(n^2) - невыполнимые. Такие пироги


## По памяти

# Указатели
---
## Стек
---
- **Стек** — это структура данных, которая работает по принципу **LIFO (Last In, First Out)**. Последний добавленный элемент будет удалён первым.

#### Примеры операций на стеке:
1. push(head, x) — добавляет элемент x на вершину стека.
2. pop(head) — удаляет элемент с вершины стека.
3. is_empty() — проверяет, пуст ли стек.
#### Оценка сложности функций стека:

| Удаление: | Добавление: | Поиск: |
| --------- | ----------- | ------ |
| О(1)      | О(1)        | O(n)   |

---
## Очередь
---
- **Очередь** — это структура данных, работающая по принципу FIFO (First In, First Out). Первый добавленный элемент будет удалён первым.

#### Основные операции:
1. enqueue(head, x) — добавляет элемент x в конец очереди.
2. dequeue(head) — удаляет элемент из начала очереди.
3. is_empty() — проверяет, пуста ли очередь.
#### Оценка сложности функций очереди:

| Удаление: | Добавление: | Поиск: |
| --------- | ----------- | ------ |
| О(1)      | О(1)        | O(n)   |

---
## Односвязный список
---
- **Односвязный список** — это структура данных, состоящая из узлов, каждый из которых хранит данные и ссылку на следующий элемент. В односвязном списке элементы связаны только в одном направлении — от первого узла к последнему.

#### Основные компоненты:
1. **Head** — указатель на первый элемент списка.
2. **Node** — структура, которая хранит данные и ссылку на следующий узел.
  
#### Основные операции:
1. Добавление в начало/конец.
2. Удаление.
##### Структура Node:
```cpp
struct Node{
    int key; //значение
    Node* next; //ссылка на следующий элемент
};
```

##### Добавление нового узла в начало списка:
```cpp
void push(Node*& head, int x){
    Node* newNode = new Node(); //создаём новый узел
    newNode->key = x; //значение узла
    newNode->next = head; //ссылка на предыдущий первый элемент
    head = newNode; //теперь это новый head
}
```

##### Добавление нового узла в конец списка:

```cpp
void push_in_end(Node*& head, int key){
    Node* newNode = new Node;    //создаём новый узел
    newNode->key = key;          //значение узла
    newNode->next = nullptr;     //новый узел будет последним, поэтому его next = nullptr

    if(head == nullptr){       //если список пуст
        head = newNode;          //новый узел становится head’ом списка
    } else{
        Node* current = head;
        while(current->next != nullptr){  //ищем последний узел
            current = current->next;
        }
        current->next = newNode;  //добавляем новый узел в конец
    }
}
```

##### Удаление head’а:
```cpp
void pop_head(Node*& head){
    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент
    delete temp;                //удаляем старый head списка
}
```

##### Удаление последнего:
```cpp
void pop_last(){
    //идём до предпоследнего элемента
    Node* current = head;
    while(current->next != nullptr && current->next->next != nullptr){
        current = current->next;
    }

    //у current теперь указатель на предпоследний элемент
    Node* lastNode = current->next;  //последний элемент
    current->next = nullptr;         //убираем связь с последним элементом

    delete lastNode;
}
```

---
## Двусвязный список
---
- **Двусвязный список** — это список, в котором каждый узел содержит ссылки на следующий и предыдущий элементы. Это улучшает доступ к элементам в обе стороны, по сравнению с односвязным списком.
#### Основные компоненты:
1. **Head и Tail** — указатели на первый и последний элементы списка.
2. **Node** — структура, содержащая данные, ссылку на следующий и ссылку на предыдущий узел.

#### Основные операции:
1. Добавление в начало/конец.
2. Удаление.
#### Структура Node:

```cpp
struct Node{
    int key;      //значение узла
    Node* prev;    //указатель на предыдущий элемент
    Node* next;    //указатель на следующий элемент
};
```

#### Добавление узла в конец:
```cpp
void add(int key){
    Node* newNode = new Node(key);  //новый узел

    tail->next = newNode;    //привязываем новый узел к текущему последнему
    newNode->prev = tail;    //устанавливаем предыдущий указатель у нового узла

    tail = newNode;          //обновляем tail
}
```

#### Добавление в начало:
```cpp
void add(int key){
    Node* newNode = new Node(key);  //создаем новый узел

    newNode->next = head;    //привязываем новый узел к текущему первому
    head->prev = newNode;    //устанавливаем предыдущий указатель у текущего первого узла
    head = newNode;          //обновляем head
}

```
  
  
#### Удаление с конца:
```cpp
void delete_tail(){
    Node* temp = tail;

    tail = tail->prev;  //обновляем tail
    tail->next = nullptr;  //разрываем связь с удаляемым узлом

    delete temp;  //удаляем старый tail
}
```

#### Удаление с начала:
```cpp
void delete_head(){
    Node* temp = head;
    
    head = head->next;  //обновляем head
    head->prev = nullptr;  //разрываем связь с удаляемым узлом

    delete temp;  //удаляем старый head
}
```

#### Удаление произвольного:
```cpp
void delete(Node* node){

    if (node->prev){
        node->prev->next = node->next;  //перенаправляем указатель на следующий узел
    }

    if (node->next){
        node->next->prev = node->prev;  //перенаправляем указатель на предыдущий узел
    }

    delete node;  //удаляем сам узел
}
```
  
  
Всё это можно объединить в один красивый псевдокод:

```cpp
void delete(Node* node){

    if (node->prev){
        node->prev->next = node->next;  //перенаправляем указатель на следующий узел
    }

    if (node->next){
        node->next->prev = node->prev;  //перенаправляем указатель на предыдущий узел
    }

    if (node == head){
        head = node->next;  //если удаляется первый элемент, обновляем head
    }

    if (node == tail){
        tail = node->prev;  // Если удаляется последний элемент, обновляем tail
    }

    delete node;  //удаляем сам узел
}
```

---
## Циклический список
---
- **Циклический список** — это разновидность связного списка (одно- или двусвязного), в котором последний узел указывает на первый элемент списка, образуя замкнутый круг.

#### Основные операции:
1. Все основные операции как в обычных связных списках (добавление, удаление, поиск).
2. Особенностью является наличие цикла, который позволяет обойти все элементы, вернувшись к началу.

  
  

Минутка реализации операций на одно- и двусвязном циклических списках!!  

### Односвязный:  
#### Добавление в конец:
```cpp
void add(int key){
    Node* newNode = new Node(key)
    Node* temp = head;

        while(temp->next != head){
            temp = temp->next;
        }

        temp->next = newNode;  //привязываем новый узел
        newNode->next = head;  //новый узел ссылается на head
}
```

#### Добавление в начало:
```cpp
void prepend(int key){
    Node* newNode = new Node(key);
    Node* temp = head;

    while(temp->next != head){  
        temp = temp->next;
    }

    temp->next = newNode;  //последний узел теперь ссылается на новый
    newNode->next = head;  //новый узел ссылается на head
    head = newNode;        //новый узел становится head'ом

}
```

Соединим в одном кодике удаление head’а и произвольного узла:

```cpp
void delete(int key){

    Node* temp = head;
    Node* prev = nullptr;
    
    //если элемент для удаления - это head
    if(head->key == key){
        Node* tail = head;
        while(tail->next != head){  //ищем последний элемент
            tail = tail->next;
        }

        head = head->next;   //head списка меняется
        tail->next = head;   //последний элемент ссылается на новый head

        delete temp;         //удаляем старый head
        return;

    }
    
    //ищем элемент в списке
    while(temp->next != head && temp->key != key){
        prev = temp;
        temp = temp->next;
    }
    if(temp->key == key){
        prev->next = temp->next; //пропускаем текущий узел
        delete temp;             //удаляем узел
    }
}
```

  
  

### Двусвязный:

#### Добавление в конец:
```cpp
void add(int key){
        Node* newNode = new Node(key);
        Node* tail = head->prev; //предыдущий элемент от head'a - это tail

        tail->next = newNode;     //tail ссылается на новый узел
        newNode->prev = tail;     //новый узел ссылается на tail
        newNode->next = head;     //новый узел ссылается на head
        head->prev = newNode;     //head ссылается на новый узел
    }
```
  
  
#### Добавление в начало:
```cpp
void add(int key){

    Node* newNode = new Node(key);
    Node* tail = head->prev; //предыдущий элемент от head - это tail

    newNode->next = head;     //новый элемент ссылается на head
    newNode->prev = tail;     //новый элемент ссылается на tail
    tail->next = newNode;     //tail ссылается на новый элемент
    head->prev = newNode;     //head ссылается на новый элемент
    head = newNode;           //новый элемент становится head'ом

}
```

  
  

Так же как и с односвязным сделаем один код для удаления:

```cpp
void delete(int key){

    Node* temp = head;
    
    //если элемент для удаления - это head
    if(head->key == key){
            Node* tail = head->prev;  //последний элемент - это элемент перед head’ом
            head = head->next;         //head списка меняется
            head->prev = tail;         //новый элемент ссылается на старый tail
            tail->next = head;         //старый tail ссылается на новый head

            delete temp;               //удаляем старый head
            return;

    }

  

    //ищем элемент в списке

    Node* prev = nullptr;
    temp = head;

    //проходим по списку, пока не найдем нужный элемент или не вернемся к head'у
    while(temp->next != head){
        if(temp->key == key){
            prev = temp->prev;
            prev->next = temp->next;    //пропускаем текущий узел
            temp->next->prev = prev;    //пропускаем текущий узел
            
            delete temp;                //удаляем узел
            return;

        }
        temp = temp->next;
    }

    //проверка последнего элемента (он указывает обратно на head)
    if(temp->key == key){

        prev = temp->prev;
        prev->next = temp->next;
        temp->next->prev = prev;

        delete temp;  //удаляем узел
    }
} 
```
  
---
## Стек на списках
---
#### Основные операции:
1. push(head, x) добавляет элемент в начало списка.
2. pop(head) удаляет первый элемент списка.

  
#### push(x):
```cpp
void push(Node*& head, int x){
    Node* newNode = new Node(); //создаём новый узел

	newNode->key = x; //значение узла
    newNode->next = head; //ссылка на предыдущий первый элемент
    head = newNode; //теперь это новый head

}
```

#### pop():

```cpp
void pop(Node*& head){

    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент

    delete temp;                //удаляем старый head списка

}
```

---
## Очередь на списках
---
#### Основные операции:
1. enqueue(head, x) добавляет элемент в конец списка.
2. dequeue(head) удаляет элемент из начала списка.

  

#### enqueue(head, x):
```cpp
void enqueue(Node*& head, int key){

    Node* newNode = new Node;    //создаём новый узел
    
    newNode->key = key;          //значение узла
    newNode->next = nullptr;     //новый узел будет последним, поэтому его next = nullptr

  

    if(head == nullptr){       //если список пуст
        head = newNode;          //новый узел становится head’ом списка
    } else{
        Node* current = head;
        while(current->next != nullptr){  //ищем последний узел
            current = current->next;
        }
        current->next = newNode;  //добавляем новый узел в конец
    }
}
```

#### dequeue(head):
```cpp
void dequeue(Node*& head){

    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент

    delete temp;                //удаляем старый head списка

}

```

# бин поиск
- Двоичный поиск заключается в том, что на каждом шаге множество значений делится на две части и дальше обрабатывается та часть множества, где находится нужное значение.

- `Правосторонний поиск` - поиск такого наибольшего (т.е. самого правого) индекса i что a[i]≤x  a[i]≤x, где x - искомый элемент.

- `Левосторонний поиск` - поиск такого наименьшего (т.е. самого левого) индекса i что as[i]≥x  a[i]≥x, где x - искомый элемент.
## Алгоритм двоичного поиска

Идея поиска заключается в том, чтобы брать элемент посередине и сравнивать его с тем который мы ищем. Если искомое больше (в случае правостороннего — не меньше), чем элемент сравнения, то сужаем область поиска так, чтобы новая левая граница была равна индексу середины. В противном случае присваиваем это значение правой границе. Проделываем эту процедуру до тех пор, пока правая граница больше левой более чем на 1.

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = -1                      // l, r — левая и правая границы
    int r = len(a)    
    while l < r - 1                // Запускаем цикл
        m = l + (r - l) / 2           // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример левостороннего бинпоиска*

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = 0                     // l, r — левая и правая границы
    int r = len(a)    
    while l < r                // Запускаем цикл
        m = l + (r - l) / 2            // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример правостороннего бинпоиска*
### Асимптотики
 - худшая *O*(log *n*)
 - лучшее *O*(1)
 - среднее *O*(log *n*)
 p.s по факту это асимптотика чисто бин поиска но к ней еще + асимптотика сортировки которую вы используете

## Нюансы
- часто встречается `(r + l) / 2` но нужно учитывать, что `r + l` может не уместиться в свой тип и тогда все пойдёт покатиться, поэтому лучше использовать `l + (r - l) / 2`

# Бинарные деревья поиска
----
- __Дерево__ - иерархическая структура данных, имеющая узлы и ребра, соединяющие эти узлы. 
  (простыми:  __Дерево__ – древовидная структура данных в виде набора связанных узлов.)

- __Узел__ - своего рода node. В нём есть ключ или значение, указатели на дочерние узлы.

- __Лист__ - узел без дочерних узлов. Указатель на дочерние - null.

- __Корень__ - самый верхний узел дерева. Так же - корневой узел.

- __Ребро__ - указатель, связывающий **два** узла.
----


- __Бинарное (*двоичное*) дерево__ — древовидная структура данных, в которой у родителя не может быть более двух детей (т.е их может не быть вовсе).

- **Бинарное (двоичное) дерево поиска** – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):
	- оба поддерева – левое и правое, являются двоичными деревьями поиска;
	
	- у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X;
	
	- у всех узлов правого поддерева произвольного узла X значения ключей данных не меньше, чем значение ключа данных узла X.
---
## Как строить Бинарное дерево поиска
---
### Пример написания узла дерева 
- *Узел дерева может хранить внутри себя значение, а так же указатель только на правый и левый детей.*
 ```cpp
 struct node {  
	 int data;    // данные  
	 node* left;  // левый потомок  
	 node* right; // правый потомок  
};
```
- так же можно хранить указатель на родительский объект (по той же системе как и в двухсвязном списке)
 ```cpp
 struct node {  
	 int data;    // данные  
	 node* left;  // левый потомок  
	 node* right; // правый потомок  
	 node* parent; // указатель на родительский объект
};
```

---
## Операции над бинарным деревом поиска
---
о майн гот ПОИСК (читать с озвучкой пина из смешариков)

### Поиск элементов дерева (O(h))
_Алгоритм:_
1. Для каждого узла, начиная с корня, значение ключа сравнивается с ключом искомым;
2. дальше два исхода: ключи одинаковые - возвращаем node, включи не совпали - рекурсивно вызывается поиск для правого либо левого поддерева (левое - <, правое - >).
3. Если элемент, передается в поиск как null - возвращаем null.
```cpp
node search (node x, int k) {
    if (x == nullptr || k = x.data){
        return x;
    }

    if (k < x.data) {
        return search(x.left, k);
    }
    else {
        return search(x.right, k);
    }
}
```


### Добавление узлов в дерево (O(h))
_Алгоритм:_
1. подается какое-то значение `z`
2. сравнивает `z` с  уже имеющимися значениями в правом и левом поддереве до тех пор пока не натыкается на `NULL`
3. подвешиваем элемент со значением `z` на место где был `NULL`

  ```cpp
  node insert (node x, int z) {
    if (x == nullptr){
        return node(z);
    }

    if (z < x.data) {
        x.left = insert(x.left, z);
    }
    else if (z > x.right) {
        x.right = insert(x.right, z);
    }

    return z;
}
```

- Вторая реализация через родителя 
_Алгоритм:_
1. `x` изначальное дерево, `z` узел/дерево которое мы вставляем
2. спускаемся по дереву до `NULL` сравнивая значения `z` и `x`
3. подвешиваем `z` делая `x` родителем
```cpp
void insert(node x, node z) {
    while (x != nullptr) {
        if (z.data > x.data) {
            if (x.data != nullptr) {
                x = x.right;
            }
            else {
                z.parent = x;
                x.right = z;
                break;
            }
        }
        else if (z.data < x.data) {
            if (x.left != nullptr) {
                x = x.left;
            }
            else {
                z.parent = x;
                x.left = z;
                break;
            }
        }
    }
}
```
### Удаление элемента (O(h))
1. Удаление листа - заменяем указатель на _null_;
2. Удаление узла с одним дочерним узлом - вставляем дочерний узел вместо удаляемого;
3. Удаление узла с двумя дочерними узлами - находим следующий за удаляемым элемент и удаляем его, после чего вставляем найденный элемент вместо удаляемого.


_Нерекурсивный способ:_
```cpp
void delete(node* x, node* z):                 // x — дерево, z — удаляемый элемент
   p = z.parent                                  // предок удаляемого элемента
   if (z.left == null and z.right == null){         // первый случай: удаляемый элемент - лист
     if (p.left == z){
       p.left = null
       }
     if (p.right == z){
       p.right = null
       }
   }else if (z.left == null or z.right == null){     // второй случай: удаляемый элемент имеет одного потомка
       if (z.left == null){                 
           if (p.left == z){
             p.left = z.right
           }else{
             p.right = z.right
             }
           z.right.parent = p 
       }else{
           if (p.left == z){
               p.left = z.left
           }else{
               p.right = z.left
	        }
           z.left.parent = p
        }
   }else{     // третий случай: удаляемый элемент имеет двух потомков
     successor = next(z, x)                   
     z.key = successor.key
     if (successor.parent.left == successor){
       successor.parent.left = successor.right
       if (successor.right != null){
         successor.right.parent = successor.parent
		}
     }else{
       successor.parent.right = successor.right
       if (successor.right != null){
         successor.right.parent = successor.parent
	    }
	 }
   }
```

_Рекурсивно:_
- ! при рекурсивном удалении узла из бинарного дерева нужно рассмотреть три случая: удаляемый элемент находится в левом поддереве текущего поддерева, удаляемый элемент находится в правом поддереве или удаляемый элемент находится в корне. В двух первых случаях нужно рекурсивно удалить элемент из нужного поддерева. Если удаляемый элемент находится в корне текущего поддерева и имеет два дочерних узла, то нужно заменить его минимальным элементом из правого поддерева и рекурсивно удалить этот минимальный элемент из правого поддерева. Иначе, если удаляемый элемент имеет один дочерний узел, нужно заменить его потомком.
```cpp
template<typename T>
node delete(node* root, T z):               // корень поддерева, удаляемый ключ
  if (root == null){
    return root
	}
  if (z < root.key){
    root.left = delete(root.left, z)
  }else if (z > root.key){
    root.right = delete(root.right, z)
  }else if (root.left != null and root.right != null){
    root.key = minimum(root.right).key
    root.right = delete(root.right, root.key)
  }else{
    if (root.left != null){
      root = root.left
    }else if (root.right != null){
      root = root.right
    }else{
      root = null
      }
	}
  return root
```
### Поиск минимального объекта (O(h))
- для поиска минимального числа нужно найти крайний левый объект
```cpp
node min(node x) {
    if (x.left == nullptr) {
        return x;
    }

    return min(x.left);
}
```

### Поиск максимального объекта (O(h))
- для поиска максимального числа нужно найти крайний правый объект
```cpp
node max(node x) {
    if (x.right == nullptr) {
        return x;
    }

    return max(x.right);
}
```
### Поиск следующего элемента. (O(h))

Следующий элемент некоторого элемента, ключ которого минимален и больше ключа элемента искомого.

**Алгоритм действия**: если у `node` есть правое поддерево, то следующий за ним элемент будет минимальным элементом в этом поддереве. Если нет правого поддерева, то нужно следовать вверх, пока не встретим узел, который является левым дочерним узлом своего родителя.

_С информацией о родителе:_
```cpp
node next(node* x){
   if (x.right != null){
      return minimum(x.right)
	}
   y = x.parent
   while (y != null and x == y.right){
      x = y
      y = y.parent
    }
   return y
}
```

_Без информации о родителе:_
```cpp
template<typename T>
node next(T x){
   node* current = root, successor = null    // root — корень дерева
   
   while (current != null){
      if (current.key > x){
         successor = current
         current = current.left
      }else{
         current = current.right
	    }
	}
   return successor
}
```

### Поиск предыдущего элемента. (O(h))

Выполняется аналогично. Если у узла есть левое поддерево, то предыдущий ему элемент будет максимальным элементом в этом поддереве. Если у него нет левого поддерева, то нужно следовать вверх, пока не встретим узел, который является правым дочерним узлом своего родителя.

_С информацией о родителе:_
```cpp
node prev(node* x){
   if (x.left != null){
      return maximum(x.left)
      }
   y = x.parent
   while (y != null and x == y.left){
      x = y
      y = y.parent
    }
   return y
}
```
---
### Обход дерева
---
_префиксная форма_
обход для ввода данных
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    cout << tree->data; //Отображаем корень дерева  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
  }  
}
```

_инфиксная форма_
обход подходит для сортировки
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева 
    cout << tree->data; //Отображаем корень дерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
  }  
}
```

_постфиксная форма_
подходит для удаления дерева тк обхо происходит по форме: левое поддерево, правое поддерево, вершина;
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
    cout << tree->data; //Отображаем корень дерева 
  }  
}
```

# Дополнительная информация (просто краткая сводка того что мб понадобиьься)

### Поиск в ширину
## anti-quick sort
Предположим, что мы разбиваем массив так, что одна часть содержит `n−1` элементов, а вторая `-1`. Поскольку процедура разбиения занимает время `Θ(n)`, для времени работы `T(n)` получаем соотношение:
![[Pasted image 20241107123058.png]]

## Асимптотики
### quick sort
| Лучший      | Средний     | Худший      |
| ----------- | ----------- | ----------- |
| О(n×log(n)) | О(n×log(n)) | О(n×log(n)) |
*затраты по памяти*:
O(n)
### merge sort
| Лучший      | Средний     | Худший |
| ----------- | ----------- | ------ |
| О(n×log(n)) | О(n×log(n)) | O(n^2) |
*затраты по памяти*:
O(1) - на списке
O(n) - для массива

### counting sort
по времени:
O(n)
по памяти:
O(n)
### radix sort
|            | Лучший случай | Средний случай | Худший случай |
| ---------- | ------------- | -------------- | ------------- |
| По времени | O(k)          | O(k)           | O(k)          |
| По памяти  | O(k + n)      | O(k + n)       | O(k + n)      |
### бин дерево
|В среднем|В худшем случае|
|---|---|
|Расход памяти|O(n)|O(n)|
|Поиск|O(log n)|O(n)|
|Вставка|O(log n)|O(n)|
|Удаление|O(log n)|O(n)|
# Инварианты
**Инвариант** – это условие, которое остаётся неизменным на протяжении всего выполнения программы. Такими условиями могут быть **значения** переменных или определенная **логика** выполнения алгоритма.

• ***Инвариант сортировки вставками*** - вся левая часть относительно текущего положения i уже отсортирована. Это явление является инвариантом, потому что не будь у нас такого условия на каждом шаге алгоритма, мы не могли бы утверждать корректность его работы после прохода по исходному массиву.

• ***Инвариант сортировки слияниями*** - технически это то, что при слиянии у вас есть два отсортированных относительно самих себя массива. Если бы у вас не было таких гарантий - нельзя было бы применить метод двух указателей и соответственно сделать слияние за O(n). Здесь в качестве инварианта также можно указать тот факт, что вы на каждом шаге разделяете текущий подмассив поровну (+/- 1 из-за возможной нечетности).

• ***Быстрая сортировка*** тоже имеет свой инвариант и он предполагает, что после каждого шага разделения, элемент-разделитель неизменно оказывается на позиции, при которой все элементы слева от него меньше или равны ему, а все элементы справа — больше. Это помогает нам гарантировать корректность сортировки и её асимптотики.
